import os
import uuid
from concurrent.futures import ThreadPoolExecutor
from contextlib import asynccontextmanager
from typing import Dict, List, Optional, Union

from asyncpg import Connection, create_pool

from db import insert_to_db, vectorize_document, get_similar_text

from fastapi import Depends, FastAPI, HTTPException, Request, UploadFile, File
from fastapi.responses import JSONResponse
from models.model_manager import ModelManager
from schemas import (
    EmbeddingInput,
    EmbeddingData,
    EmbeddingOutput,
    DocumentInput,
    DocumentProcessInput,
    DocumentProcessOutput,
    SearchRequest,
    SearchResult,
)


# from services.x_auth_token import get_x_token_key

# HINT: postgresql://username:password@host:port/database
#       host=postgres (service name in docker-compose)
# postgres running in a CONTAINER as a service
# DATABASE_URL=postgresql://postgres:example@postgres:5432/postgres
# postgres as a process running locally on mac
# DATABASE_URL=postgresql://postgres:example@localhost:5432/postgres

EM_PORT = int(os.getenv("EM_PORT", 3004))
HOST = os.getenv("HOST", "0.0.0.0")

POSTGRES_USER = os.getenv("POSTGRES_USER", "postgres")
POSTGRES_DB = os.getenv("POSTGRES_DB", "postgres")
POSTGRES_HOST = os.getenv("POSTGRES_HOST", "postgres")
EMBEDDING_MODEL_NAME = os.getenv("EMBEDDING_MODEL_NAME", "no_name_model")
POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD", "example")
DATABASE_URL = f"postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_HOST}:5432/{POSTGRES_DB}"


@asynccontextmanager
async def get_db_connection(request: Request) -> Connection:
    """Asynchronous context manager for acquiring and releasing
    a database connection from a connection pool
    """
    async with request.app.state.db_pool.acquire() as connection:
        yield connection  # return connection to the pool


@asynccontextmanager
async def app_lifespan(app: FastAPI) -> None:
    """Asynchronous context manager for initializing and closing
    the database connection pool when the application starts and stops
    """
    global embed_model
    embed_model = ModelManager()
    app.state.db_pool = await create_pool(DATABASE_URL)
    yield  # the FastAPI app runs and serves requests
    await app.state.db_pool.close()


app = FastAPI(
    lifespan=app_lifespan,
    # dependencies=[Depends(get_x_token_key)],
    title="Document Embedding Microservice",
    description="""
    This microservice uses a LLM to solve NLP related problems.
            """,
)

# Creates a pool of threads that can execute calls asynchronously
executor = ThreadPoolExecutor(max_workers=os.cpu_count() // 2)

embed_model: Optional[ModelManager] = None


# model name **********************************************************************************
@app.get(
    "/model_name",
    response_model=str,
    summary="Get the name of the model currently in use.",
)
async def get_model_name():
    """
    Returns the name of the model currently in use.
    """
    if not EMBEDDING_MODEL_NAME:
        raise HTTPException(status_code=404, detail="Model name not set")
    return JSONResponse(content={"model_name": EMBEDDING_MODEL_NAME})


# /v1/embeddings ******************************************************************************
@app.post(
    "/v1/embeddings",
    response_model=EmbeddingOutput,
)
async def get_embeddings_endpoint(data: EmbeddingInput) -> EmbeddingOutput:
    """Generate embeddings for the provided text list and estimate token usage."""
    if embed_model is None:
        print("Model not initialized")
        raise HTTPException(status_code=500, detail="Model not initialized")

    try:
        result = await embed_model.embed_documents(data.input)
        return result
    except Exception as e:
        print(e)
        raise HTTPException(status_code=500, detail=str(e))


# document processor **************************************************************************
@app.post(
    "/v1/ingest",
    response_model=DocumentProcessOutput,
    description="""
    Process a text chunk, store it in the database and return embeddings and the uuid.
    UUID is generated by the database and is used to retrieve the text chunk from the database.
    """,
)
async def text_processor_endpoint(data: DocumentProcessInput, request: Request):
    try:
        async with get_db_connection(request) as connection:
            async with connection.transaction():
                # Convert the Pydantic model to a dictionary
                document_dict = data.input.model_dump()
                response = await insert_to_db(connection, document_dict, embed_model)
            return response
    except Exception as e:
        print(e)
        raise HTTPException(status_code=500, detail=str(e))


# ingest_documents ****************************************************************************
@app.post("/ingest_document")
async def ingest_document(request: Request, file: UploadFile = File(...)):
    try:
        # Establish a database connection
        async with get_db_connection(request) as connection:
            # Generate a unique filename using only UUID
            # temp_filename = f"temp_{uuid.uuid4()}.txt"
            temp_filename = file.filename
            # Read the file's content as bytes
            file_content = file.file.read()

            # Save the uploaded file temporarily
            with open(temp_filename, "w+") as file_object:
                file_content_str = file_content.decode("utf-8")
                file_object.write(file_content_str)

            # Process the document
            await vectorize_document(
                temp_filename, connection, embed_model
            )  # Adjust as needed

            # Clean up: Delete the temporary file after processing
            os.remove(temp_filename)

        return {"message": f"Document {file.filename} processed successfully"}
    except Exception as e:
        print(e)
        raise HTTPException(status_code=500, detail=str(e))


# search *************************************************************************************
@app.post("/v1/search", response_model=SearchResult)
async def semantic_search(input: SearchRequest, request: Request):
    try:
        async with get_db_connection(request) as connection:
            async with connection.transaction():
                results = await get_similar_text(
                    connection=connection,
                    embed_model=embed_model,
                    text_for_search=input.text_for_search,
                    n_top=input.n_top,
                    search_in_embeddings_only=input.search_in_embeddings_only,
                )
            return SearchResult(matched_texts=results)
    except Exception as e:
        print(e)
        raise HTTPException(status_code=500, detail=str(e))


def run():
    import uvicorn

    print(f"Starting the server on {HOST}:{EM_PORT}")
    uvicorn.run("main:app", host=HOST, port=EM_PORT, reload=False)


# changes while debugging in VSC:
# 1. client-files/.env: change HOST to localhost
# 2. set reload=True in run() function HERE
